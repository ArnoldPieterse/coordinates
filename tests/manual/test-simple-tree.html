<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Tree Generator Test</title>
    <style>
        body { font-family: monospace; background: #f8f8f8; color: #222; }
        pre { background: #eee; padding: 1em; border-radius: 8px; }
        .container { max-width: 1200px; margin: 2em auto; }
        h1 { font-size: 1.5em; }
        .axis-indicator { font-size: 12px; color: #888; margin-left: 8px; }
        .axis-svg { vertical-align: middle; }
        .svg-row { display: flex; flex-direction: row; justify-content: space-between; gap: 16px; margin-bottom: 24px; }
        .svg-view { display: flex; flex-direction: column; align-items: center; }
    </style>
</head>
<body>
<div class="container">
    <div style="margin-bottom: 10px;">
        <button type="button" class="preset-btn" id="preset-oak">Oak</button>
        <button type="button" class="preset-btn" id="preset-pine">Pine</button>
        <button type="button" class="preset-btn" id="preset-willow">Willow</button>
    </div>
    <form id="tree-controls" style="margin-bottom: 1em; background: #f0f0f0; padding: 10px; border-radius: 8px;">
        <label><input type="checkbox" id="split-mode" checked> Initial Branch Split: Two branches (Y/V split)</label>
        <label style="margin-left:20px;">Initial Branch Split Count: <input type="number" id="initial-branch-split" min="1" max="8" value="2" style="width:40px;"></label>
        <label style="margin-left:20px;">Branch Count: <input type="number" id="branch-count" min="1" max="16" value="4" style="width:40px;"></label>
        <label style="margin-left:20px;">Randomness: <input type="number" id="randomness" min="0" max="2" step="0.01" value="0.7" style="width:50px;"></label>
        <label style="margin-left:20px;">Variation: <input type="range" id="variation" min="0" max="2" step="0.01" value="0.3" style="width:80px;"> <span id="variation-value">0.30</span></label>
        <label style="margin-left:20px;">Root Complexity: <input type="range" id="root-complexity" min="0.2" max="1" step="0.01" value="0.5" style="width:80px;"> <span id="root-complexity-value">0.50</span></label>
        <label style="margin-left:20px;"><input type="checkbox" id="golden-mode" checked> Golden Ratio Mode</label>
        <button type="submit" style="margin-left:20px;">Regenerate Tree</button>
    </form>
    <div class="svg-row">
        <div class="svg-view" id="svg-container"></div>
        <div class="svg-view" id="svg-side-container"></div>
        <div class="svg-view" id="svg-top-container"></div>
    </div>
    <div style="font-size:14px; margin-bottom:10px; color:#444;">
        <strong>View Axes:</strong> Front (x/y), Side (x/z), Top (y/z)
    </div>
    <h1>Simple Tree Generator - Step 4 Validation</h1>
    <ul id="checklist">
        <li>✅ Path extraction implemented</li>
        <li>✅ All branch segments extracted</li>
        <li>✅ Tree is rendered visually as SVG</li>
        <li>✅ Output matches tree structure</li>
        <li>✅ Three.js mesh generation implemented</li>
        <li>✅ 3D visualization with materials and leaves</li>
    </ul>
    <div style="margin-bottom: 10px;">
        <button type="button" id="toggle-3d">Show 3D View</button>
        <button type="button" id="export-obj">Export OBJ</button>
    </div>
    <div id="three-container" style="display: none; width: 400px; height: 400px; border: 1px solid #ccc; margin: 10px 0;"></div>
    <div id="output"></div>
</div>
<script type="module">
let result = null;
import { testStep4, generateTreeRecursive, TreeOptions, Branch, extractSegments, sphericalDirection, generateTreeMesh } from './src/simple-tree-generator.js';
import * as THREE from './src/three.module.js';

function renderTree(splitMode, randomness, initialBranchSplit, branchCount, goldenMode, variation, rootComplexity) {
    const PHI = 1.61803398875;
    const FIBS = [1, 2, 3, 5, 8, 13];
    // Set average tree options
    const opts = new TreeOptions({ levels: 5, angle: 45, length: 12, children: branchCount, radius: 1 });
    let root, rootsRoot;
    if (splitMode) {
        // Phantom root, two base branches
        root = new Branch({ origin: { x: 0, y: 0, z: 0 }, direction: { x: 0, y: 1, z: 0 }, length: 0, radius: opts.radius, level: 0 });
        const baseAngle = Math.PI / 6; // 30 degrees from vertical
        const dirs = [
            { x: Math.sin(baseAngle), y: Math.cos(baseAngle), z: 0 },
            { x: -Math.sin(baseAngle), y: Math.cos(baseAngle), z: 0 }
        ];
        for (const dir of dirs) {
            // Vary initial branch length
            const lengthFactor = 1 - variation + 2 * variation * Math.random();
            // Add angle variation to initial branches (tree: upward)
            const minPhi = Math.PI * 30 / 180;
            const maxPhi = Math.PI * 80 / 180;
            const phi = minPhi + (maxPhi - minPhi) * Math.random() + (Math.random() - 0.5) * variation * Math.PI;
            // Use theta from base direction
            const theta = Math.atan2(dir.z, dir.x);
            const initDir = sphericalDirection({ x: 0, y: 1, z: 0 }, theta, phi);
            const child = new Branch({
                origin: { ...root.origin },
                direction: initDir,
                length: opts.length * lengthFactor,
                radius: opts.radius,
                level: 1
            });
            root.children.push(child);
            customRecursive(opts, child, 1, randomness, branchCount, null, false, goldenMode, PHI, FIBS, variation);
        }
    } else {
        // Single trunk, then split into initialBranchSplit at first level
        root = new Branch({ origin: { x: 0, y: 0, z: 0 }, direction: { x: 0, y: 1, z: 0 }, length: opts.length, radius: opts.radius, level: 0 });
        customRecursive(opts, root, 0, randomness, branchCount, initialBranchSplit, false, goldenMode, PHI, FIBS, variation);
    }

    // ROOTS: use rootComplexity ratio for levels and branch count
    const rootLevels = Math.max(1, Math.round(opts.levels * rootComplexity));
    const rootBranchCount = Math.max(1, Math.round(branchCount * rootComplexity));
    const rootInitialSplit = 4; // Always 4 base root branches
    const rootOpts = new TreeOptions({ levels: rootLevels, angle: 45, length: opts.length * 1.2, children: rootBranchCount, radius: opts.radius * 0.8 });
    rootsRoot = new Branch({ origin: { x: 0, y: 0, z: 0 }, direction: { x: 0, y: -1, z: 0 }, length: 0, radius: rootOpts.radius, level: 0 });
    for (let i = 0; i < rootInitialSplit; i++) {
        const angle = (i / rootInitialSplit) * 2 * Math.PI;
        // Add angle variation to initial root branches (downward)
        const minPhi = Math.PI * 100 / 180;
        const maxPhi = Math.PI * 150 / 180;
        const phi = minPhi + (maxPhi - minPhi) * Math.random() + (Math.random() - 0.5) * variation * Math.PI;
        const theta = angle;
        const dir = sphericalDirection({ x: 0, y: -1, z: 0 }, theta, phi);
        // Vary initial root branch length
        const lengthFactor = 1 - variation + 2 * variation * Math.random();
        const child = new Branch({
            origin: { ...rootsRoot.origin },
            direction: dir,
            length: rootOpts.length * lengthFactor,
            radius: rootOpts.radius,
            level: 1
        });
        rootsRoot.children.push(child);
        customRecursive(rootOpts, child, 1, randomness, rootBranchCount, null, true, goldenMode, PHI, FIBS, variation);
    }

    const segments = extractSegments(root);
    const rootSegments = extractSegments(rootsRoot);
    result = { opts, root, segments, rootOpts, rootsRoot, rootSegments };

    // Output JSON
    const outputDiv = document.getElementById('output');
    outputDiv.innerHTML = `
    <h2>TreeOptions</h2>
    <pre>${JSON.stringify(result.opts, null, 2)}</pre>
    <h2>Tree Structure (root branch)</h2>
    <pre>${JSON.stringify(result.root, null, 2)}</pre>
    <h2>Extracted Segments</h2>
    <pre>${JSON.stringify(result.segments, null, 2)}</pre>
    <h2>Step 4: Mesh Generation Test</h2>
    <div id="mesh-test-results"></div>
    `;

    // Test Step 4 functionality
    testStep4MeshGeneration(result.segments, THREE);

    // Clear SVG containers
    document.getElementById('svg-container').innerHTML = '';
    document.getElementById('svg-side-container').innerHTML = '';
    document.getElementById('svg-top-container').innerHTML = '';

    // Add color legend above SVGs only if not already present
    if (!document.getElementById('color-legend')) {
        const legendDiv = document.createElement('div');
        legendDiv.id = 'color-legend';
        legendDiv.style.margin = '10px 0 10px 0';
        legendDiv.innerHTML = `
            <span style="display:inline-block;width:18px;height:4px;background:#228b22;vertical-align:middle;margin-right:4px;"></span> Tree
            <span style="display:inline-block;width:18px;height:4px;background:#8B4513;vertical-align:middle;margin:0 4px 0 16px;"></span> Roots
        `;
        const container = document.querySelector('.container');
        const svgRow = document.querySelector('.svg-row');
        if (svgRow) {
            container.insertBefore(legendDiv, svgRow);
        } else {
            container.appendChild(legendDiv);
        }
    }

    // Render SVG
    const svgW = 400, svgH = 400;
    const margin = 20;
    function project(p) {
        return {
            x: svgW/2 + p.x * 15,
            y: svgH - margin - p.y * 15
        };
    }
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', svgW);
    svg.setAttribute('height', svgH);
    svg.style.background = '#fff';
    svg.style.border = '1px solid #ccc';
    // Tree segments (green)
    for (const seg of result.segments) {
        const s = project(seg.start), e = project(seg.end);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', e.x);
        line.setAttribute('y2', e.y);
        line.setAttribute('stroke', '#228b22');
        line.setAttribute('stroke-width', '2');
        svg.appendChild(line);
    }
    // Root segments (brown, thicker)
    for (const seg of result.rootSegments) {
        const s = project(seg.start), e = project(seg.end);
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', e.x);
        line.setAttribute('y2', e.y);
        line.setAttribute('stroke', '#8B4513'); // brown
        line.setAttribute('stroke-width', '3');
        svg.appendChild(line);
    }
    // Draw intersection objects (orange circles) at each branch origin, with connection count
    function drawIntersects(branch, color, radius) {
        const p = project(branch.origin);
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', p.x);
        circle.setAttribute('cy', p.y);
        circle.setAttribute('r', radius);
        circle.setAttribute('fill', color);
        svg.appendChild(circle);
        // Draw connection count
        const count = branch.children.length;
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', p.x + radius + 2);
        text.setAttribute('y', p.y + 4);
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', '#222');
        text.textContent = count;
        svg.appendChild(text);
        for (const child of branch.children) {
            drawIntersects(child, color, radius);
        }
    }
    drawIntersects(result.root, '#ff9900', 4); // tree intersections
    if (result.rootsRoot) drawIntersects(result.rootsRoot, '#ff6600', 5); // root intersections, slightly larger
    document.getElementById('svg-container').appendChild(svg);

    // Compute z range for centering
    const zVals = result.segments.flatMap(seg => [seg.start.z, seg.end.z]);
    const zMin = Math.min(...zVals);
    const zMax = Math.max(...zVals);
    const zMid = (zMin + zMax) / 2;

    // Define projection functions for side and top views
    function projectSide(p) {
        return { x: svgW/2 + (p.z - zMid) * 15, y: svgH - margin - p.y * 15 };
    }
    function projectTop(p) {
        return { x: svgW/2 + p.x * 15, y: svgH/2 - (p.z - zMid) * 15 };
    }

    // Render side view SVG (x/z projection)
    const svgSide = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgSide.setAttribute('width', svgW);
    svgSide.setAttribute('height', svgH);
    svgSide.style.background = '#fff';
    svgSide.style.border = '1px solid #ccc';
    for (const seg of result.segments) {
        // Side view: z (horizontal, right), y (vertical, up)
        const s = { x: svgW/2 + (seg.start.z - zMid) * 15, y: svgH - margin - seg.start.y * 15 };
        const e = { x: svgW/2 + (seg.end.z - zMid) * 15, y: svgH - margin - seg.end.y * 15 };
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', e.x);
        line.setAttribute('y2', e.y);
        line.setAttribute('stroke', '#1e90ff');
        line.setAttribute('stroke-width', '2');
        svgSide.appendChild(line);
    }
    for (const seg of result.rootSegments) {
        const s = { x: svgW/2 + (seg.start.z - zMid) * 15, y: svgH - margin - seg.start.y * 15 };
        const e = { x: svgW/2 + (seg.end.z - zMid) * 15, y: svgH - margin - seg.end.y * 15 };
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', e.x);
        line.setAttribute('y2', e.y);
        line.setAttribute('stroke', '#8B4513');
        line.setAttribute('stroke-width', '3');
        svgSide.appendChild(line);
    }
    // Draw intersection objects for side view, with connection count
    function drawIntersectsSide(branch, color, radius) {
        const p = { x: svgW/2 + (branch.origin.z - zMid) * 15, y: svgH - margin - branch.origin.y * 15 };
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', p.x);
        circle.setAttribute('cy', p.y);
        circle.setAttribute('r', radius);
        circle.setAttribute('fill', color);
        svgSide.appendChild(circle);
        // Draw connection count
        const count = branch.children.length;
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', p.x + radius + 2);
        text.setAttribute('y', p.y + 4);
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', '#222');
        text.textContent = count;
        svgSide.appendChild(text);
        for (const child of branch.children) {
            drawIntersectsSide(child, color, radius);
        }
    }
    drawIntersectsSide(result.root, '#ff9900', 4);
    if (result.rootsRoot) drawIntersectsSide(result.rootsRoot, '#ff6600', 5);
    const label1 = document.createElement('div');
    label1.textContent = 'Front View (x/y)';
    label1.style.margin = '10px 0 2px 0';
    const label2 = document.createElement('div');
    label2.textContent = 'Side View (y/z)';
    label2.style.margin = '10px 0 2px 0';
    const svgContainer = document.getElementById('svg-container');
    const svgSideContainer = document.getElementById('svg-side-container');
    svgContainer.append(label1);
    svgSideContainer.append(label2);
    svgContainer.appendChild(svg);
    svgSideContainer.appendChild(svgSide);

    // Add axis indicators
    function axisSVG(xLabel, yLabel) {
        return `<svg width="40" height="40" class="axis-svg"><line x1="10" y1="30" x2="30" y2="30" stroke="#888" stroke-width="2" marker-end="url(#arrow)"/><line x1="10" y1="30" x2="10" y2="10" stroke="#888" stroke-width="2" marker-end="url(#arrow)"/><defs><marker id="arrow" markerWidth="6" markerHeight="6" refX="5" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L6,3 z" fill="#888"/></marker></defs><text x="32" y="34">${xLabel}</text><text x="2" y="8">${yLabel}</text></svg>`;
    }
    svgContainer.insertAdjacentHTML('beforeend', `<div class="axis-indicator">${axisSVG('x','y')}</div>`);
    svgSideContainer.insertAdjacentHTML('beforeend', `<div class="axis-indicator">${axisSVG('z','y')}</div>`);

    // Render top view SVG (x/z projection)
    const svgTop = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svgTop.setAttribute('width', svgW);
    svgTop.setAttribute('height', svgH);
    svgTop.style.background = '#fff';
    svgTop.style.border = '1px solid #ccc';

    // Top view: x (horizontal), z (vertical, centered)
    for (const seg of result.segments) {
        const s = { x: svgW/2 + seg.start.x * 15, y: svgH/2 - (seg.start.z - zMid) * 15 };
        const e = { x: svgW/2 + seg.end.x * 15, y: svgH/2 - (seg.end.z - zMid) * 15 };
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', e.x);
        line.setAttribute('y2', e.y);
        line.setAttribute('stroke', '#b8860b');
        line.setAttribute('stroke-width', '2');
        svgTop.appendChild(line);
    }
    for (const seg of result.rootSegments) {
        const s = { x: svgW/2 + seg.start.x * 15, y: svgH/2 - (seg.start.z - zMid) * 15 };
        const e = { x: svgW/2 + seg.end.x * 15, y: svgH/2 - (seg.end.z - zMid) * 15 };
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', e.x);
        line.setAttribute('y2', e.y);
        line.setAttribute('stroke', '#8B4513');
        line.setAttribute('stroke-width', '3');
        svgTop.appendChild(line);
    }
    // Draw intersection objects for top view, with connection count
    function drawIntersectsTop(branch, color, radius) {
        const p = { x: svgW/2 + branch.origin.x * 15, y: svgH/2 - (branch.origin.z - zMid) * 15 };
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', p.x);
        circle.setAttribute('cy', p.y);
        circle.setAttribute('r', radius);
        circle.setAttribute('fill', color);
        svgTop.appendChild(circle);
        // Draw connection count
        const count = branch.children.length;
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', p.x + radius + 2);
        text.setAttribute('y', p.y + 4);
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', '#222');
        text.textContent = count;
        svgTop.appendChild(text);
        for (const child of branch.children) {
            drawIntersectsTop(child, color, radius);
        }
    }
    drawIntersectsTop(result.root, '#ff9900', 4);
    if (result.rootsRoot) drawIntersectsTop(result.rootsRoot, '#ff6600', 5);

    const label3 = document.createElement('div');
    label3.textContent = 'Top View (x/z)';
    label3.style.margin = '10px 0 2px 0';
    const svgTopContainer = document.getElementById('svg-top-container');
    svgTopContainer.append(label3);
    svgTopContainer.appendChild(svgTop);
    svgTopContainer.insertAdjacentHTML('beforeend', `<div class="axis-indicator">${axisSVG('x','z')}</div>`);

    // Helper: Generate a cubic Bézier curve between two points with two control points
    function cubicBezier(p0, p1, p2, p3, t) {
        const u = 1 - t;
        return {
            x: u*u*u*p0.x + 3*u*u*t*p1.x + 3*u*t*t*p2.x + t*t*t*p3.x,
            y: u*u*u*p0.y + 3*u*u*t*p1.y + 3*u*t*t*p2.y + t*t*t*p3.y,
            z: u*u*u*p0.z + 3*u*u*t*p1.z + 3*u*t*t*p2.z + t*t*t*p3.z
        };
    }
    // Helper: Draw a wireframe cube (voxel) at a given center and orientation
    function drawVoxel(svg, center, size, project) {
        // Cube vertices relative to center
        const d = size / 2;
        const verts = [
            {x: center.x-d, y: center.y-d, z: center.z-d},
            {x: center.x+d, y: center.y-d, z: center.z-d},
            {x: center.x+d, y: center.y+d, z: center.z-d},
            {x: center.x-d, y: center.y+d, z: center.z-d},
            {x: center.x-d, y: center.y-d, z: center.z+d},
            {x: center.x+d, y: center.y-d, z: center.z+d},
            {x: center.x+d, y: center.y+d, z: center.z+d},
            {x: center.x-d, y: center.y+d, z: center.z+d}
        ];
        // Cube edges
        const edges = [
            [0,1],[1,2],[2,3],[3,0], // bottom
            [4,5],[5,6],[6,7],[7,4], // top
            [0,4],[1,5],[2,6],[3,7]  // sides
        ];
        const pts2d = verts.map(project);
        for (const [a, b] of edges) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', pts2d[a].x);
            line.setAttribute('y1', pts2d[a].y);
            line.setAttribute('x2', pts2d[b].x);
            line.setAttribute('y2', pts2d[b].y);
            line.setAttribute('stroke', '#00bfff');
            line.setAttribute('stroke-width', '1.5');
            svg.appendChild(line);
        }
    }
    // Overlay voxels along a curvy branch path
    function overlayVoxelsAndFaces(branch, project, svg) {
        for (const child of branch.children) {
            // Generate control points for cubic Bézier
            const p0 = branch.origin;
            const p3 = child.origin;
            // Control points: offset from straight line for bending
            const dir = {
                x: p3.x - p0.x,
                y: p3.y - p0.y,
                z: p3.z - p0.z
            };
            // Randomized bend
            const bend = 0.3 + 0.4 * Math.random();
            const perp = { x: -dir.z, y: 0, z: dir.x };
            const len = Math.sqrt(perp.x*perp.x + perp.y*perp.y + perp.z*perp.z) || 1;
            perp.x /= len; perp.y /= len; perp.z /= len;
            const mag = bend * Math.sqrt(dir.x*dir.x + dir.y*dir.y + dir.z*dir.z);
            const p1 = {
                x: p0.x + dir.x * 0.3 + perp.x * mag,
                y: p0.y + dir.y * 0.3 + perp.y * mag,
                z: p0.z + dir.z * 0.3 + perp.z * mag
            };
            const p2 = {
                x: p0.x + dir.x * 0.7 - perp.x * mag,
                y: p0.y + dir.y * 0.7 - perp.y * mag,
                z: p0.z + dir.z * 0.7 - perp.z * mag
            };
            // Sample points along the curve
            const steps = 7;
            const ringSegments = 8;
            const radius = (branch.radius || 1) * 0.8;
            let prevRing2d = null;
            for (let i = 0; i <= steps; ++i) {
                const t = i / steps;
                const pt = cubicBezier(p0, p1, p2, p3, t);
                // Generate ring in 3D
                // Estimate tangent
                const t1 = Math.max(0, t - 0.01), t2 = Math.min(1, t + 0.01);
                const pt1 = cubicBezier(p0, p1, p2, p3, t1);
                const pt2 = cubicBezier(p0, p1, p2, p3, t2);
                const tangent = { x: pt2.x - pt1.x, y: pt2.y - pt1.y, z: pt2.z - pt1.z };
                // Find up/right vectors
                let up = { x: 0, y: 1, z: 0 };
                const dot = (tangent.x*up.x + tangent.y*up.y + tangent.z*up.z) / (Math.sqrt(tangent.x**2 + tangent.y**2 + tangent.z**2) * 1);
                if (Math.abs(dot) > 0.99) up = { x: 1, y: 0, z: 0 };
                // right = tangent x up
                const right = {
                    x: tangent.y*up.z - tangent.z*up.y,
                    y: tangent.z*up.x - tangent.x*up.z,
                    z: tangent.x*up.y - tangent.y*up.x
                };
                // up = right x tangent
                up = {
                    x: right.y*tangent.z - right.z*tangent.y,
                    y: right.z*tangent.x - right.x*tangent.z,
                    z: right.x*tangent.y - right.y*tangent.x
                };
                // Normalize right and up
                const rlen = Math.sqrt(right.x**2 + right.y**2 + right.z**2) || 1;
                right.x /= rlen; right.y /= rlen; right.z /= rlen;
                const ulen = Math.sqrt(up.x**2 + up.y**2 + up.z**2) || 1;
                up.x /= ulen; up.y /= ulen; up.z /= ulen;
                // Generate ring points
                const ring2d = [];
                for (let j = 0; j < ringSegments; ++j) {
                    const theta = (j / ringSegments) * Math.PI * 2;
                    const offset = {
                        x: Math.cos(theta) * radius * right.x + Math.sin(theta) * radius * up.x,
                        y: Math.cos(theta) * radius * right.y + Math.sin(theta) * radius * up.y,
                        z: Math.cos(theta) * radius * right.z + Math.sin(theta) * radius * up.z
                    };
                    const p3d = { x: pt.x + offset.x, y: pt.y + offset.y, z: pt.z + offset.z };
                    ring2d.push(project(p3d));
                }
                // Draw faces between prevRing2d and ring2d
                if (prevRing2d) {
                    for (let j = 0; j < ringSegments; ++j) {
                        const a = prevRing2d[j];
                        const b = ring2d[j];
                        const c = ring2d[(j+1)%ringSegments];
                        const d = prevRing2d[(j+1)%ringSegments];
                        const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        polygon.setAttribute('points', `${a.x},${a.y} ${b.x},${b.y} ${c.x},${c.y} ${d.x},${d.y}`);
                        polygon.setAttribute('fill', '#aee9c7');
                        polygon.setAttribute('fill-opacity', '0.5');
                        polygon.setAttribute('stroke', 'none');
                        svg.appendChild(polygon);
                    }
                }
                prevRing2d = ring2d;
                // Draw blue voxel for reference
                drawVoxel(svg, pt, 1.2, project);
            }
            overlayVoxelsAndFaces(child, project, svg);
        }
    }
    // Use new overlayVoxelsAndFaces for all three views
    overlayVoxelsAndFaces(result.root, project, svg);
    if (result.rootsRoot) overlayVoxelsAndFaces(result.rootsRoot, project, svg);
    overlayVoxelsAndFaces(result.root, projectSide, svgSide);
    if (result.rootsRoot) overlayVoxelsAndFaces(result.rootsRoot, projectSide, svgSide);
    overlayVoxelsAndFaces(result.root, projectTop, svgTop);
    if (result.rootsRoot) overlayVoxelsAndFaces(result.rootsRoot, projectTop, svgTop);
}

function customRecursive(options, parent, level = 0, randomness = 1, branchCount = 3, initialBranchSplit = null, isRoot = false, goldenMode = false, PHI = 1.618, FIBS = [1,2,3,5,8,13], variation = 0.2) {
    if (level >= options.levels) return;
    const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~137.5°
    let childrenCount;
    // Allometric scaling: fewer splits at higher levels
    const maxSplits = Math.max(1, Math.floor(branchCount * (1 - 0.5 * (level / options.levels))));
    if (level === 1 && initialBranchSplit !== null) {
        childrenCount = initialBranchSplit;
    } else if (level === 0 && initialBranchSplit !== null) {
        childrenCount = 1;
    } else if (goldenMode) {
        const fibChoices = FIBS.filter(f => f <= maxSplits);
        childrenCount = fibChoices.length > 0 ? fibChoices[Math.floor(Math.random() * fibChoices.length)] : 1;
    } else {
        // More splits at lower levels, fewer at higher, with variation
        const splitProb = Math.max(0.2, 1 - (level / options.levels) + variation * (Math.random() - 0.5));
        if (Math.random() < splitProb) {
            childrenCount = Math.floor(Math.random() * (maxSplits + 1));
        } else {
            childrenCount = 1;
        }
    }
    for (let i = 0; i < childrenCount; i++) {
        const heightFrac = level / Math.max(1, options.levels - 1);
        // Allometric scaling for length
        let baseLength = options.length * (goldenMode ? Math.pow(1/PHI, level) : (1 - 0.2 * heightFrac));
        baseLength *= 1 - variation + 2 * variation * Math.random(); // ±variation*2
        // Clamp branch length to 40%-120% of parent length
        baseLength = Math.max(parent.length * 0.4, Math.min(parent.length * 1.2, baseLength));
        // Allometric scaling for radius
        const baseRadius = options.radius * (1 - 0.3 * heightFrac);
        // Contextual angle rules
        let minAngle, maxAngle;
        if (isRoot) {
            minAngle = Math.PI * 100 / 180; // 100°
            maxAngle = Math.PI * 160 / 180; // 160°
        } else if (heightFrac < 0.3) {
            minAngle = Math.PI * 20 / 180; // more horizontal
            maxAngle = Math.PI * 60 / 180;
        } else if (heightFrac > 0.7) {
            minAngle = Math.PI * 60 / 180; // more vertical
            maxAngle = Math.PI * 80 / 180;
        } else {
            minAngle = Math.PI * 40 / 180;
            maxAngle = Math.PI * 70 / 180;
        }
        // Add extra random offset to angles, but clamp
        let phi = minAngle + (maxAngle - minAngle) * Math.random() * randomness + (Math.random() - 0.5) * variation * Math.PI;
        phi = Math.max(minAngle, Math.min(maxAngle, phi));
        // Use golden angle for azimuth, but bias away from previous branches (avoid overlap)
        let theta = i * goldenAngle + (Math.random() - 0.5) * 0.2 * randomness + (Math.random() - 0.5) * variation * 2 * Math.PI;
        // Tropism/geotropism: strong bias
        if (isRoot) {
            // Downward bias
            phi += Math.PI * 0.1 * (1 + heightFrac); // more downward at deeper levels
            phi = Math.min(maxAngle, phi);
        } else {
            // Upward bias
            phi -= Math.PI * 0.1 * (1 + heightFrac); // more upward at higher levels
            phi = Math.max(minAngle, phi);
        }
        let dir = sphericalDirection({ x: 0, y: isRoot ? -1 : 1, z: 0 }, theta, phi);
        if (isRoot) dir.y = -Math.abs(dir.y); // force downward
        else dir.y = Math.abs(dir.y); // force upward
        // Small random upward/downward kick
        dir.y += (Math.random() - 0.5) * 0.05 * (isRoot ? -1 : 1);
        dir.x += (Math.random() - 0.5) * 0.1 * randomness;
        dir.z += (Math.random() - 0.5) * 0.1 * randomness;
        // Normalize
        const len = Math.sqrt(dir.x * dir.x + dir.y * dir.y + dir.z * dir.z) || 1;
        dir = { x: dir.x / len, y: dir.y / len, z: dir.z / len };
        const child = new Branch({
            origin: {
                x: parent.origin.x + parent.direction.x * parent.length,
                y: parent.origin.y + parent.direction.y * parent.length,
                z: parent.origin.z + parent.direction.z * parent.length
            },
            direction: dir,
            length: baseLength,
            radius: baseRadius,
            level: level + 1
        });
        parent.children.push(child);
        customRecursive(options, child, level + 1, randomness, branchCount, null, isRoot, goldenMode, PHI, FIBS, variation);
    }
}

// Initial render
const splitModeInput = document.getElementById('split-mode');
const initialBranchSplitInput = document.getElementById('initial-branch-split');
const branchCountInput = document.getElementById('branch-count');
const randomnessInput = document.getElementById('randomness');
const goldenModeInput = document.getElementById('golden-mode');
const variationInput = document.getElementById('variation');
const variationValue = document.getElementById('variation-value');
const rootComplexityInput = document.getElementById('root-complexity');
const rootComplexityValue = document.getElementById('root-complexity-value');
const form = document.getElementById('tree-controls');
function getVals() {
    return [splitModeInput.checked, parseFloat(randomnessInput.value), parseInt(initialBranchSplitInput.value, 10), parseInt(branchCountInput.value, 10), goldenModeInput.checked, parseFloat(variationInput.value), parseFloat(rootComplexityInput.value)];
}
form.addEventListener('submit', e => {
    e.preventDefault();
    const [splitMode, randomness, initialBranchSplit, branchCount, goldenMode, variation, rootComplexity] = getVals();
    renderTree(splitMode, randomness, initialBranchSplit, branchCount, goldenMode, variation, rootComplexity);
});
variationInput.addEventListener('input', () => {
    variationValue.textContent = parseFloat(variationInput.value).toFixed(2);
});
rootComplexityInput.addEventListener('input', () => {
    rootComplexityValue.textContent = parseFloat(rootComplexityInput.value).toFixed(2);
});
// Initial render
renderTree(splitModeInput.checked, parseFloat(randomnessInput.value), parseInt(initialBranchSplitInput.value, 10), parseInt(branchCountInput.value, 10), goldenModeInput.checked, parseFloat(variationInput.value), parseFloat(rootComplexityInput.value));
// Preset button logic
function setPreset(preset) {
    if (preset === 'oak') {
        splitModeInput.checked = true;
        initialBranchSplitInput.value = 2;
        branchCountInput.value = 4;
        randomnessInput.value = 0.7;
        variationInput.value = 0.3;
        rootComplexityInput.value = 0.5;
        goldenModeInput.checked = true;
    } else if (preset === 'pine') {
        splitModeInput.checked = true;
        initialBranchSplitInput.value = 2;
        branchCountInput.value = 3;
        randomnessInput.value = 0.5;
        variationInput.value = 0.2;
        rootComplexityInput.value = 0.3;
        goldenModeInput.checked = true;
    } else if (preset === 'willow') {
        splitModeInput.checked = true;
        initialBranchSplitInput.value = 3;
        branchCountInput.value = 6;
        randomnessInput.value = 1.0;
        variationInput.value = 0.6;
        rootComplexityInput.value = 0.7;
        goldenModeInput.checked = true;
    }
    variationValue.textContent = parseFloat(variationInput.value).toFixed(2);
    rootComplexityValue.textContent = parseFloat(rootComplexityInput.value).toFixed(2);
    renderTree(splitModeInput.checked, parseFloat(randomnessInput.value), parseInt(initialBranchSplitInput.value, 10), parseInt(branchCountInput.value, 10), goldenModeInput.checked, parseFloat(variationInput.value), parseFloat(rootComplexityInput.value));
}
document.getElementById('preset-oak').onclick = () => setPreset('oak');
document.getElementById('preset-pine').onclick = () => setPreset('pine');
document.getElementById('preset-willow').onclick = () => setPreset('willow');

// Step 4: 3D Visualization
let currentTreeMesh = null;
let threeScene = null;
let threeRenderer = null;
let threeCamera = null;

// Initialize Three.js scene
function initThreeJS() {
    if (typeof THREE === 'undefined') {
        console.warn('Three.js not available');
        return false;
    }

    const container = document.getElementById('three-container');
    const width = container.clientWidth;
    const height = container.clientHeight;

    // Scene
    threeScene = new THREE.Scene();
    threeScene.background = new THREE.Color(0xf0f0f0);

    // Camera
    threeCamera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    threeCamera.position.set(20, 20, 20);
    threeCamera.lookAt(0, 10, 0);

    // Renderer
    threeRenderer = new THREE.WebGLRenderer({ antialias: true });
    threeRenderer.setSize(width, height);
    threeRenderer.shadowMap.enabled = true;
    threeRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
    container.appendChild(threeRenderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
    threeScene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    threeScene.add(directionalLight);

    // Ground plane
    const groundGeometry = new THREE.PlaneGeometry(50, 50);
    const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    threeScene.add(ground);

    return true;
}

// Render 3D tree
function render3DTree(segments) {
    if (!threeScene) {
        if (!initThreeJS()) return;
    }

    // Clear existing tree
    if (currentTreeMesh) {
        threeScene.remove(currentTreeMesh);
    }

    // Generate new tree mesh
    currentTreeMesh = generateTreeMesh(segments, {
        trunkColor: 0x8B4513,
        branchColor: 0xA0522D,
        leafColor: 0x228B22,
        trunkRadius: 1.0,
        branchRadiusFactor: 0.7,
        leafSize: 2.0,
        addLeaves: true,
        ringSegments: 8,
        smoothNormals: true,
        root: result.root
    }, THREE);

    if (currentTreeMesh) {
        currentTreeMesh.castShadow = true;
        currentTreeMesh.receiveShadow = true;
        threeScene.add(currentTreeMesh);
        animate();
    }
}

// Animation loop
function animate() {
    if (!threeRenderer || !threeScene || !threeCamera) return;
    
    requestAnimationFrame(animate);
    
    // Rotate camera around tree
    const time = Date.now() * 0.001;
    const radius = 30;
    threeCamera.position.x = Math.cos(time * 0.5) * radius;
    threeCamera.position.z = Math.sin(time * 0.5) * radius;
    threeCamera.position.y = 20;
    threeCamera.lookAt(0, 10, 0);
    
    threeRenderer.render(threeScene, threeCamera);
}

// Export OBJ function
function exportOBJ() {
    if (!currentTreeMesh) {
        alert('No tree mesh to export');
        return;
    }

    let obj = '';
    let vertexOffset = 1;

    // Traverse all meshes in the tree group
    currentTreeMesh.traverse((child) => {
        if (child.isMesh) {
            const geometry = child.geometry;
            const position = geometry.getAttribute('position');
            const index = geometry.getIndex();

            // Add vertices
            for (let i = 0; i < position.count; i++) {
                const x = position.getX(i);
                const y = position.getY(i);
                const z = position.getZ(i);
                obj += `v ${x} ${y} ${z}\n`;
            }

            // Add faces
            if (index) {
                for (let i = 0; i < index.count; i += 3) {
                    const a = index.getX(i) + vertexOffset;
                    const b = index.getX(i + 1) + vertexOffset;
                    const c = index.getX(i + 2) + vertexOffset;
                    obj += `f ${a} ${b} ${c}\n`;
                }
            } else {
                // No index buffer, assume triangles
                for (let i = 0; i < position.count; i += 3) {
                    const a = i + vertexOffset;
                    const b = i + 1 + vertexOffset;
                    const c = i + 2 + vertexOffset;
                    obj += `f ${a} ${b} ${c}\n`;
                }
            }

            vertexOffset += position.count;
        }
    });

    // Download file
    const blob = new Blob([obj], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'tree.obj';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Event listeners
document.getElementById('toggle-3d').addEventListener('click', () => {
    const container = document.getElementById('three-container');
    const isVisible = container.style.display !== 'none';
    
    if (isVisible) {
        container.style.display = 'none';
        document.getElementById('toggle-3d').textContent = 'Show 3D View';
    } else {
        container.style.display = 'block';
        document.getElementById('toggle-3d').textContent = 'Hide 3D View';
        
        // Generate 3D tree if we have segments
        const segments = extractSegments(result.root);
        render3DTree(segments);
    }
});

document.getElementById('export-obj').addEventListener('click', exportOBJ);

// Test Step 4 mesh generation
function testStep4MeshGeneration(segments, THREE) {
    const resultsDiv = document.getElementById('mesh-test-results');
    let results = '<ul>';
    
    try {
        // Test 1: Basic mesh generation
        const mesh = generateTreeMesh(segments, undefined, THREE);
        if (mesh) {
            results += '<li>✅ Mesh generation successful</li>';
            results += `<li>✅ Mesh type: ${mesh.type}</li>`;
            results += `<li>✅ Children count: ${mesh.children.length}</li>`;
            
            // Count different mesh types
            let trunkCount = 0, branchCount = 0, leafCount = 0;
            mesh.traverse((child) => {
                if (child.isMesh) {
                    if (child.material.color.getHex() === 0x8B4513) trunkCount++;
                    else if (child.material.color.getHex() === 0xA0522D) branchCount++;
                    else if (child.material.color.getHex() === 0x228B22) leafCount++;
                }
            });
            
            results += `<li>✅ Trunk meshes: ${trunkCount}</li>`;
            results += `<li>✅ Branch meshes: ${branchCount}</li>`;
            results += `<li>✅ Leaf meshes: ${leafCount}</li>`;
        } else {
            results += '<li>❌ Mesh generation failed</li>';
        }
        
        // Test 2: Custom options
        const customMesh = generateTreeMesh(segments, {
            trunkColor: 0xFF0000,
            branchColor: 0x00FF00,
            leafColor: 0x0000FF,
            trunkRadius: 2.0,
            branchRadiusFactor: 0.5,
            leafSize: 3.0,
            addLeaves: false,
            ringSegments: 12
        }, THREE);
        
        if (customMesh) {
            results += '<li>✅ Custom options mesh generation successful</li>';
        } else {
            results += '<li>❌ Custom options mesh generation failed</li>';
        }
        
        // Test 3: Performance test
        const startTime = performance.now();
        for (let i = 0; i < 10; i++) {
            generateTreeMesh(segments, undefined, THREE);
        }
        const endTime = performance.now();
        const avgTime = (endTime - startTime) / 10;
        results += `<li>✅ Average mesh generation time: ${avgTime.toFixed(2)}ms</li>`;
        
    } catch (error) {
        results += `<li>❌ Error in mesh generation: ${error.message}</li>`;
    }
    
    results += '</ul>';
    resultsDiv.innerHTML = results;
}
</script>
</body>
</html> 